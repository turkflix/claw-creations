<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake üêç</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #eee;
    }
    
    h1 {
      margin-bottom: 10px;
      font-size: 2rem;
    }
    
    #score {
      margin-bottom: 15px;
      font-size: 1.2rem;
      color: #0f0;
    }
    
    #game-canvas {
      border: 3px solid #0f0;
      border-radius: 5px;
      background: #0d0d1a;
    }
    
    #message {
      margin-top: 15px;
      font-size: 1rem;
      color: #888;
    }
    
    #controls {
      margin-top: 20px;
      color: #666;
      font-size: 0.9rem;
    }

    /* Mobile controls */
    #mobile-controls {
      display: none;
      margin-top: 20px;
      gap: 5px;
    }
    
    .ctrl-row {
      display: flex;
      justify-content: center;
      gap: 5px;
    }
    
    .ctrl-btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
      border: 2px solid #0f0;
      background: #1a1a2e;
      color: #0f0;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
    }
    
    .ctrl-btn:active {
      background: #0f0;
      color: #1a1a2e;
    }
    
    @media (max-width: 500px) {
      #mobile-controls {
        display: flex;
        flex-direction: column;
      }
      #controls {
        display: none;
      }
    }
  </style>
</head>
<body>
  <h1>üêç Snake</h1>
  <div id="score">Score: 0</div>
  <canvas id="game-canvas" width="400" height="400"></canvas>
  <div id="message">Press any arrow key to start</div>
  <div id="controls">Arrow keys to move ‚Ä¢ Space to restart</div>
  
  <div id="mobile-controls">
    <div class="ctrl-row">
      <button class="ctrl-btn" data-dir="up">‚¨ÜÔ∏è</button>
    </div>
    <div class="ctrl-row">
      <button class="ctrl-btn" data-dir="left">‚¨ÖÔ∏è</button>
      <button class="ctrl-btn" data-dir="down">‚¨áÔ∏è</button>
      <button class="ctrl-btn" data-dir="right">‚û°Ô∏è</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const messageEl = document.getElementById('message');
    
    const gridSize = 20;
    const tileCount = canvas.width / gridSize;
    
    let snake = [];
    let food = { x: 0, y: 0 };
    let direction = { x: 0, y: 0 };
    let nextDirection = { x: 0, y: 0 };
    let score = 0;
    let gameRunning = false;
    let gameOver = false;
    let gameLoop;
    
    function init() {
      snake = [
        { x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }
      ];
      direction = { x: 0, y: 0 };
      nextDirection = { x: 0, y: 0 };
      score = 0;
      gameOver = false;
      gameRunning = false;
      scoreEl.textContent = `Score: ${score}`;
      messageEl.textContent = 'Press any arrow key to start';
      spawnFood();
      draw();
    }
    
    function spawnFood() {
      do {
        food.x = Math.floor(Math.random() * tileCount);
        food.y = Math.floor(Math.random() * tileCount);
      } while (snake.some(seg => seg.x === food.x && seg.y === food.y));
    }
    
    function update() {
      direction = { ...nextDirection };
      
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };
      
      // Wall collision
      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        endGame();
        return;
      }
      
      // Self collision
      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        endGame();
        return;
      }
      
      snake.unshift(head);
      
      // Eat food
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = `Score: ${score}`;
        spawnFood();
      } else {
        snake.pop();
      }
      
      draw();
    }
    
    function draw() {
      // Clear
      ctx.fillStyle = '#0d0d1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid (subtle)
      ctx.strokeStyle = '#1a1a2e';
      for (let i = 0; i <= tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }
      
      // Draw food
      ctx.fillStyle = '#ff0055';
      ctx.beginPath();
      ctx.arc(
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        gridSize / 2 - 2,
        0,
        Math.PI * 2
      );
      ctx.fill();
      
      // Draw snake
      snake.forEach((seg, i) => {
        const brightness = Math.max(100, 255 - i * 10);
        ctx.fillStyle = `rgb(0, ${brightness}, 0)`;
        ctx.fillRect(
          seg.x * gridSize + 1,
          seg.y * gridSize + 1,
          gridSize - 2,
          gridSize - 2
        );
      });
    }
    
    function endGame() {
      gameOver = true;
      gameRunning = false;
      clearInterval(gameLoop);
      messageEl.textContent = `Game Over! Score: ${score} ‚Ä¢ Space to restart`;
    }
    
    function startGame() {
      if (gameRunning) return;
      gameRunning = true;
      messageEl.textContent = '';
      gameLoop = setInterval(update, 100);
    }
    
    function setDirection(x, y) {
      // Prevent reversing
      if (direction.x === -x && direction.y === -y) return;
      if (direction.x === x && direction.y === y) return;
      
      nextDirection = { x, y };
      
      if (!gameRunning && !gameOver) {
        startGame();
      }
    }
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && gameOver) {
        init();
        return;
      }
      
      switch (e.code) {
        case 'ArrowUp':
        case 'KeyW':
          setDirection(0, -1);
          break;
        case 'ArrowDown':
        case 'KeyS':
          setDirection(0, 1);
          break;
        case 'ArrowLeft':
        case 'KeyA':
          setDirection(-1, 0);
          break;
        case 'ArrowRight':
        case 'KeyD':
          setDirection(1, 0);
          break;
      }
    });
    
    // Mobile controls
    document.querySelectorAll('.ctrl-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (gameOver) {
          init();
          return;
        }
        
        const dir = btn.dataset.dir;
        switch (dir) {
          case 'up': setDirection(0, -1); break;
          case 'down': setDirection(0, 1); break;
          case 'left': setDirection(-1, 0); break;
          case 'right': setDirection(1, 0); break;
        }
      });
    });
    
    // Initialize
    init();
  </script>
</body>
</html>
